{
  "master": {
    "tasks": [
      {
        "id": 12,
        "title": "Setup Progressive Web App (PWA) Foundation",
        "description": "Initialize the PWA project structure with offline-first architecture, service worker configuration, and caching strategies for field use",
        "details": "Create a Next.js or React PWA with service worker registration. Configure Workbox for caching strategies including 'My Work' tickets, community data, contacts, and sites. Implement manifest.json with proper icons and offline fallback pages. Set up IndexedDB for local storage with Dexie.js or similar. Configure build pipeline for PWA optimization.\n\n```javascript\n// service-worker.js\nself.addEventListener('install', (event) => {\n  event.waitUntil(\n    caches.open('work-orders-v1').then((cache) => {\n      return cache.addAll(['/offline', '/my-work', '/communities']);\n    })\n  );\n});\n```",
        "testStrategy": "Verify PWA installation prompts appear, offline functionality works, and Lighthouse PWA audit scores 90+. Test caching behavior and service worker registration across different browsers.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Next.js or React Project with PWA Support",
            "description": "Set up the base project structure using Next.js or React, and integrate a PWA plugin (such as next-pwa) to enable service worker registration and offline-first capabilities.",
            "dependencies": [],
            "details": "Create a new Next.js or React application. Install and configure the next-pwa package (or equivalent) to handle service worker registration and PWA scaffolding. Ensure the project is ready for further PWA-specific enhancements.",
            "status": "pending",
            "testStrategy": "Verify that the application builds successfully, the service worker is registered, and the app shell loads offline."
          },
          {
            "id": 2,
            "title": "Configure Service Worker and Workbox for Custom Caching Strategies",
            "description": "Set up and customize the service worker using Workbox to implement caching strategies for 'My Work' tickets, community data, contacts, and sites.",
            "dependencies": [
              "12.1"
            ],
            "details": "Edit the Workbox configuration to define runtime and precaching rules for key data endpoints and static assets. Ensure offline access to critical resources and implement cache versioning and updates.",
            "status": "pending",
            "testStrategy": "Test offline access to cached resources, validate cache updates, and inspect service worker behavior in DevTools."
          },
          {
            "id": 3,
            "title": "Implement manifest.json with Icons and Offline Fallback Pages",
            "description": "Create and configure the web app manifest file with appropriate metadata, icons, and offline fallback pages for installation and offline support.",
            "dependencies": [
              "12.1"
            ],
            "details": "Generate manifest.json with required fields (name, short_name, start_url, display, theme_color, background_color, icons). Add icons in multiple sizes to the public directory. Implement offline fallback pages for navigation when the network is unavailable.",
            "status": "pending",
            "testStrategy": "Verify PWA installability, correct icon display, and offline fallback page rendering when disconnected."
          },
          {
            "id": 4,
            "title": "Set Up IndexedDB Local Storage with Dexie.js",
            "description": "Integrate IndexedDB using Dexie.js (or similar) to provide robust local storage for offline data persistence.",
            "dependencies": [
              "12.1"
            ],
            "details": "Install Dexie.js, define database schema for offline data (e.g., tickets, contacts), and implement CRUD operations for local-first data access. Ensure data sync strategies are ready for future implementation.",
            "status": "pending",
            "testStrategy": "Test data persistence and retrieval in offline mode, and validate data integrity after reconnecting."
          },
          {
            "id": 5,
            "title": "Configure Build Pipeline for PWA Optimization",
            "description": "Optimize the build process for PWA performance, including asset minification, service worker generation, and cache busting.",
            "dependencies": [
              "12.2",
              "12.3",
              "12.4"
            ],
            "details": "Update build scripts to include PWA optimizations such as SWC minification, static asset hashing, and automated service worker generation. Ensure generated files (e.g., sw.js, workbox-*.js) are handled correctly in version control.",
            "status": "pending",
            "testStrategy": "Run Lighthouse PWA audit to confirm a score of 90+, check build artifacts, and verify that generated service worker files are excluded from source control."
          }
        ]
      },
      {
        "id": 13,
        "title": "Design and Implement Core Database Schema",
        "description": "Create the minimal data model with WorkOrder, WorkOrderMessage, WorkOrderEvent tables and supporting entities with proper indexing and constraints",
        "details": "Implement PostgreSQL schema with row-level security (RLS). Create tables: WorkOrder (id, status, site_id, customer_id, contact_id, owner_user_id, tags[], external_ref, last_activity, reopen_count, created_at, updated_at), WorkOrderMessage (id, work_order_id, sender enum, visibility enum, body, attachments[], created_at), WorkOrderEvent (id, work_order_id, event_type, actor, occurred_at, metadata jsonb), SiteManagerAssignment, WorkOrderWatcher. Add proper indexes on frequently queried fields (site_id, owner_user_id, status, created_at). Implement RLS policies based on user branch and site assignments.\n\n```sql\nCREATE TABLE work_orders (\n  id SERIAL PRIMARY KEY,\n  status work_order_status DEFAULT 'new',\n  site_id INTEGER REFERENCES sites(id),\n  external_ref VARCHAR(255),\n  reopen_count INTEGER DEFAULT 0,\n  created_at TIMESTAMP DEFAULT NOW()\n);\n```",
        "testStrategy": "Run database migrations, verify RLS policies prevent unauthorized access, test all foreign key constraints, and validate index performance with sample data.",
        "priority": "high",
        "dependencies": [
          12
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement Multi-Channel Intake System",
        "description": "Build automated ticket creation from email, SMS, and customer portal with intelligent parsing and site/contact linking",
        "details": "Create intake processors for each channel: Email webhook handler (SendGrid/Mailgun), SMS webhook (Twilio), and portal API endpoint. Implement message parsing to extract subject, body, and identify site/contact using regex patterns, keywords, or ML-based classification. Create deduplication logic checking external_ref and site_id within 60-day window. Auto-assign 'New' status and trigger manager notifications.\n\n```javascript\n// email-intake.js\nasync function processInboundEmail(emailData) {\n  const parsed = parseEmailContent(emailData);\n  const site = await identifySite(parsed.from, parsed.subject);\n  const existingTicket = await findDuplicateTicket(parsed.external_ref, site.id);\n  \n  if (existingTicket) {\n    return appendToExistingTicket(existingTicket, parsed);\n  }\n  return createNewWorkOrder(parsed, site);\n}\n```",
        "testStrategy": "Test email parsing accuracy, SMS integration, duplicate detection within 60-day window, and verify proper site/contact linking with various message formats.",
        "priority": "high",
        "dependencies": [
          13
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Build Ticket Status Management and Lifecycle",
        "description": "Implement the New -> Open -> Closed status progression with automatic reopening logic and audit trail logging",
        "details": "Create status transition handlers with validation rules: New->Open (on assignment), Open->Closed (with required reason), Closed->Open (on customer reply). Implement automatic reopening when public messages are received on closed tickets. Log all status changes as WorkOrderEvents with actor, timestamp, and metadata. Increment reopen_count on automatic reopening.\n\n```javascript\nclass WorkOrderStatusManager {\n  async transitionStatus(workOrderId, newStatus, actor, reason = null) {\n    const workOrder = await this.getWorkOrder(workOrderId);\n    this.validateTransition(workOrder.status, newStatus);\n    \n    await this.updateStatus(workOrderId, newStatus);\n    await this.logEvent('status_changed', workOrderId, actor, { from: workOrder.status, to: newStatus, reason });\n  }\n}\n```",
        "testStrategy": "Test all valid status transitions, verify invalid transitions are rejected, confirm automatic reopening triggers correctly, and validate audit trail completeness.",
        "priority": "high",
        "dependencies": [
          13
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Develop Assignment System and Notifications",
        "description": "Create ticket assignment functionality with auto-watching for site managers and comprehensive notification system",
        "details": "Implement assignment logic that changes New tickets to Open status. Create auto-watching system that adds all site managers as watchers on ticket creation. Build notification service supporting in-app, push, email, and SMS fallbacks. Handle notification types: work_order.created, work_order.assigned, work_order.reopened. Implement notification preferences and delivery tracking.\n\n```javascript\nclass AssignmentService {\n  async assignTicket(workOrderId, assigneeId, assignerId) {\n    await this.updateOwner(workOrderId, assigneeId);\n    await this.transitionToOpen(workOrderId);\n    await this.notifyAssignee(assigneeId, workOrderId);\n    await this.logAssignmentEvent(workOrderId, assignerId, assigneeId);\n  }\n}\n```",
        "testStrategy": "Verify assignment changes status correctly, confirm all site managers become watchers, test notification delivery across all channels, and validate notification preferences.",
        "priority": "medium",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Build Manager View - 'My Communities'",
        "description": "Create the primary manager dashboard showing New and Open tickets for assigned communities with quick actions",
        "details": "Build responsive dashboard component displaying tickets filtered by user's site assignments. Implement quick actions: Assign (dropdown with team members), Close (with reason modal), Reply (inline composer), Add Internal Note. Include sorting, filtering, and search functionality. Show ticket metadata: status, priority, last activity, customer info. Implement real-time updates using WebSockets or Server-Sent Events.\n\n```jsx\nfunction MyCommunitiesView() {\n  const { tickets, loading } = useManagerTickets();\n  \n  return (\n    <TicketList>\n      {tickets.map(ticket => (\n        <TicketCard key={ticket.id} ticket={ticket}>\n          <QuickActions\n            onAssign={(userId) => assignTicket(ticket.id, userId)}\n            onClose={(reason) => closeTicket(ticket.id, reason)}\n            onReply={(message) => replyToTicket(ticket.id, message)}\n          />\n        </TicketCard>\n      ))}\n    </TicketList>\n  );\n}\n```",
        "testStrategy": "Test filtering by site assignments, verify quick actions work correctly, confirm real-time updates, and validate responsive design across devices.",
        "priority": "medium",
        "dependencies": [
          16
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Build Individual View - 'My Work'",
        "description": "Create personalized dashboard with sections for Newly Assigned, Reopened, and All Open tickets assigned to the user",
        "details": "Develop user-specific dashboard with three distinct sections using tabs or accordion layout. Implement smart sorting: Newly Assigned (by assignment date), Reopened to Me (by reopen date), All Open (by last activity). Add visual indicators for reopened tickets (badges, highlighting). Include ticket preview with customer info, site details, and last message snippet. Implement infinite scroll or pagination for performance.\n\n```jsx\nfunction MyWorkView() {\n  const { newlyAssigned, reopened, allOpen } = useMyWorkTickets();\n  \n  return (\n    <TabContainer>\n      <Tab label={`Newly Assigned (${newlyAssigned.length})`}>\n        <TicketSection tickets={newlyAssigned} showNewBadge />\n      </Tab>\n      <Tab label={`Reopened (${reopened.length})`}>\n        <TicketSection tickets={reopened} showReopenedBadge />\n      </Tab>\n      <Tab label={`All Open (${allOpen.length})`}>\n        <TicketSection tickets={allOpen} />\n      </Tab>\n    </TabContainer>\n  );\n}\n```",
        "testStrategy": "Verify correct ticket categorization, test badge visibility for reopened tickets, confirm sorting accuracy, and validate performance with large ticket volumes.",
        "priority": "medium",
        "dependencies": [
          16
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Build Coverage View - 'Branch Open by Property'",
        "description": "Create branch-level oversight view showing all Open tickets grouped by community/property for coverage managers",
        "details": "Implement hierarchical view grouping tickets by property/community within user's branch. Show ticket counts per property, expandable sections, and summary statistics. Include branch-level filtering and search capabilities. Add bulk actions for coverage scenarios. Implement property-level metrics (average response time, ticket volume trends).\n\n```jsx\nfunction CoverageView() {\n  const { propertiesWithTickets } = useBranchTickets();\n  \n  return (\n    <PropertyGroupContainer>\n      {propertiesWithTickets.map(property => (\n        <PropertySection key={property.id} property={property}>\n          <PropertyHeader>\n            {property.name} ({property.openTickets.length})\n          </PropertyHeader>\n          <ExpandableTicketList tickets={property.openTickets} />\n        </PropertySection>\n      ))}\n    </PropertyGroupContainer>\n  );\n}\n```",
        "testStrategy": "Test branch-based filtering, verify property grouping accuracy, confirm expandable sections work correctly, and validate bulk action functionality.",
        "priority": "medium",
        "dependencies": [
          16
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Implement Unified Communication Thread",
        "description": "Build chronological timeline displaying all messages, internal notes, and system events with proper visibility controls",
        "details": "Create timeline component showing WorkOrderMessages and WorkOrderEvents in chronological order. Implement visibility controls (public/internal) with clear visual distinction. Add message composition with rich text editor, attachment support, and visibility toggle. Include system event formatting (assignments, status changes) with proper icons and descriptions. Support message threading and replies.\n\n```jsx\nfunction CommunicationTimeline({ workOrderId }) {\n  const { messages, events } = useWorkOrderCommunication(workOrderId);\n  const timeline = mergeCommunicationItems(messages, events);\n  \n  return (\n    <TimelineContainer>\n      {timeline.map(item => (\n        <TimelineItem key={item.id} type={item.type}>\n          {item.type === 'message' ? (\n            <MessageBubble message={item} />\n          ) : (\n            <SystemEvent event={item} />\n          )}\n        </TimelineItem>\n      ))}\n      <MessageComposer onSend={sendMessage} />\n    </TimelineContainer>\n  );\n}\n```",
        "testStrategy": "Test chronological ordering, verify visibility controls work correctly, confirm attachment handling, and validate system event display formatting.",
        "priority": "medium",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Implement Offline Queue and Synchronization",
        "description": "Build outbox queue system for offline actions with optimistic UI and automatic sync when connectivity returns",
        "details": "Create offline action queue using IndexedDB to store pending operations (replies, assignments, status changes, photo uploads). Implement optimistic UI updates that immediately reflect changes locally. Build sync service that processes queue when online, handling server timestamps and conflict resolution. Add connection status indicator and sync progress feedback.\n\n```javascript\nclass OfflineQueue {\n  async queueAction(action) {\n    await this.db.actions.add({\n      id: generateId(),\n      type: action.type,\n      payload: action.payload,\n      timestamp: Date.now(),\n      status: 'pending'\n    });\n    this.updateUIOptimistically(action);\n  }\n  \n  async syncWhenOnline() {\n    const pendingActions = await this.db.actions.where('status').equals('pending').toArray();\n    for (const action of pendingActions) {\n      await this.syncAction(action);\n    }\n  }\n}\n```",
        "testStrategy": "Test offline action queuing, verify optimistic UI updates, confirm sync accuracy when online, and validate conflict resolution scenarios.",
        "priority": "high",
        "dependencies": [
          12,
          20
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Build File Attachment System with Offline Support",
        "description": "Implement photo and file attachment functionality that works offline with local caching and sync capabilities",
        "details": "Create file upload component supporting photos and documents with drag-drop interface. Implement local file caching using IndexedDB for offline access. Build thumbnail generation for images and file type icons. Add compression for photos to optimize storage and bandwidth. Create upload queue that processes when online with progress indicators.\n\n```javascript\nclass AttachmentManager {\n  async addAttachment(file, workOrderId) {\n    const compressed = await this.compressImage(file);\n    const thumbnail = await this.generateThumbnail(compressed);\n    \n    const attachment = {\n      id: generateId(),\n      file: compressed,\n      thumbnail,\n      workOrderId,\n      uploaded: false\n    };\n    \n    await this.cacheLocally(attachment);\n    this.queueForUpload(attachment);\n    return attachment;\n  }\n}\n```",
        "testStrategy": "Test file upload functionality, verify offline caching works, confirm thumbnail generation, and validate upload queue processing when online.",
        "priority": "medium",
        "dependencies": [
          21
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Implement AI-Powered Assistance Features",
        "description": "Build AI suggestions for reply generation, conversation summarization, and tone adjustment for internal staff use",
        "details": "Integrate OpenAI API or similar service for AI assistance features. Create suggestion engine for reply generation based on conversation context and common responses. Implement conversation summarization for long threads. Add tone adjustment (professional, friendly, concise) and text shortening features. Include AI confidence indicators and allow manual editing of suggestions.\n\n```javascript\nclass AIAssistant {\n  async generateReply(conversationHistory, context) {\n    const prompt = this.buildPrompt(conversationHistory, context);\n    const response = await openai.chat.completions.create({\n      model: 'gpt-4',\n      messages: [{ role: 'system', content: prompt }],\n      max_tokens: 200\n    });\n    \n    return {\n      suggestion: response.choices[0].message.content,\n      confidence: this.calculateConfidence(response)\n    };\n  }\n}\n```",
        "testStrategy": "Test AI suggestion accuracy, verify conversation summarization quality, confirm tone adjustment functionality, and validate API integration reliability.",
        "priority": "low",
        "dependencies": [
          20
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Implement Voice-to-Text Functionality",
        "description": "Add voice recording and transcription capabilities with offline audio memo support and online transcription",
        "details": "Implement browser Web Speech API for real-time voice-to-text. Add audio recording functionality using MediaRecorder API for offline memos. Integrate cloud transcription service (Google Speech-to-Text, Azure Speech) for offline recordings. Create audio player component for playback before transcription. Include noise reduction and audio quality optimization.\n\n```javascript\nclass VoiceToText {\n  startRecording() {\n    this.recognition = new webkitSpeechRecognition();\n    this.recognition.continuous = true;\n    this.recognition.onresult = (event) => {\n      const transcript = event.results[event.results.length - 1][0].transcript;\n      this.updateTextArea(transcript);\n    };\n    this.recognition.start();\n  }\n  \n  async recordOfflineAudio() {\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n    this.mediaRecorder = new MediaRecorder(stream);\n    this.audioChunks = [];\n    this.mediaRecorder.ondataavailable = (event) => {\n      this.audioChunks.push(event.data);\n    };\n  }\n}\n```",
        "testStrategy": "Test real-time speech recognition accuracy, verify offline audio recording, confirm transcription service integration, and validate audio quality across devices.",
        "priority": "low",
        "dependencies": [
          21
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Build Multi-Language Translation Support",
        "description": "Implement translate-to-English preview for inbound non-English messages with language detection",
        "details": "Integrate translation service (Google Translate API, Azure Translator) for automatic language detection and English translation. Add translation preview toggle in message display. Implement confidence scoring for translation quality. Cache translations to avoid repeated API calls. Include original text preservation and translation disclaimer.\n\n```javascript\nclass TranslationService {\n  async translateMessage(message) {\n    const detectedLanguage = await this.detectLanguage(message.body);\n    \n    if (detectedLanguage === 'en') {\n      return { translated: false, original: message.body };\n    }\n    \n    const translation = await this.translateText(message.body, detectedLanguage, 'en');\n    \n    return {\n      translated: true,\n      original: message.body,\n      translation: translation.text,\n      sourceLanguage: detectedLanguage,\n      confidence: translation.confidence\n    };\n  }\n}\n```",
        "testStrategy": "Test language detection accuracy, verify translation quality across multiple languages, confirm caching functionality, and validate translation preview UI.",
        "priority": "low",
        "dependencies": [
          14
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Implement Comprehensive Audit Trail and Reporting",
        "description": "Build complete event logging system with filterable timeline view and exportable audit reports",
        "details": "Create comprehensive WorkOrderEvent logging for all significant actions (created, assigned, status_changed, message_added, reopened, closed, attachment_added). Build filterable audit timeline with date range, event type, and actor filters. Implement export functionality (CSV, PDF) for audit reports. Add event search and advanced filtering capabilities. Include event metadata display and drill-down details.\n\n```javascript\nclass AuditTrailService {\n  async logEvent(eventType, workOrderId, actor, metadata = {}) {\n    const event = {\n      work_order_id: workOrderId,\n      event_type: eventType,\n      actor: actor,\n      occurred_at: new Date(),\n      metadata: metadata\n    };\n    \n    await this.db.workOrderEvents.create(event);\n    this.notifySubscribers(event);\n  }\n  \n  async exportAuditTrail(workOrderId, filters = {}) {\n    const events = await this.getFilteredEvents(workOrderId, filters);\n    return this.generateReport(events, 'csv');\n  }\n}\n```",
        "testStrategy": "Verify all events are logged correctly, test filtering and search functionality, confirm export formats work properly, and validate audit trail completeness.",
        "priority": "medium",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-28T03:57:01.813Z",
      "updated": "2025-08-29T02:04:10.511Z",
      "description": "Tasks for master context"
    }
  }
}